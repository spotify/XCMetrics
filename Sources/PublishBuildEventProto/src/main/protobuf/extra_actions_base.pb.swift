// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: src/main/protobuf/extra_actions_base.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2014 The Bazel Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// proto definitions for the blaze extra_action feature.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A list of extra actions and metadata for the print_action command.
public struct Blaze_ExtraActionSummary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var action: [Blaze_DetailedExtraActionInfo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// An individual action printed by the print_action command.
public struct Blaze_DetailedExtraActionInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If the given action was included in the output due to a request for a
  /// specific file, then this field contains the name of that file so that the
  /// caller can correctly associate the extra action with that file.
  ///
  /// The data in this message is currently not sufficient to run the action on a
  /// production machine, because not all necessary input files are identified,
  /// especially for C++.
  ///
  /// There is no easy way to fix this; we could require that all header files
  /// are declared and then add all of them here (which would be a huge superset
  /// of the files that are actually required), or we could run the include
  /// scanner and add those files here.
  public var triggeringFile: String {
    get {return _storage._triggeringFile ?? String()}
    set {_uniqueStorage()._triggeringFile = newValue}
  }
  /// Returns true if `triggeringFile` has been explicitly set.
  public var hasTriggeringFile: Bool {return _storage._triggeringFile != nil}
  /// Clears the value of `triggeringFile`. Subsequent reads from it will return its default value.
  public mutating func clearTriggeringFile() {_uniqueStorage()._triggeringFile = nil}

  /// The actual action.
  public var action: Blaze_ExtraActionInfo {
    get {return _storage._action ?? Blaze_ExtraActionInfo()}
    set {_uniqueStorage()._action = newValue}
  }
  /// Returns true if `action` has been explicitly set.
  public var hasAction: Bool {return _storage._action != nil}
  /// Clears the value of `action`. Subsequent reads from it will return its default value.
  public mutating func clearAction() {_uniqueStorage()._action = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Provides information to an extra_action on the original action it is
/// shadowing.
public struct Blaze_ExtraActionInfo: SwiftProtobuf.ExtensibleMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The label of the ActionOwner of the shadowed action.
  public var owner: String {
    get {return _owner ?? String()}
    set {_owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return self._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {self._owner = nil}

  /// Only set if the owner is an Aspect.
  /// Corresponds to AspectValue.AspectKey.getAspectClass.getName()
  /// This field is deprecated as there might now be
  /// multiple aspects applied to the same target.
  /// This is the aspect name of the last aspect
  /// in 'aspects' (8) field.
  public var aspectName: String {
    get {return _aspectName ?? String()}
    set {_aspectName = newValue}
  }
  /// Returns true if `aspectName` has been explicitly set.
  public var hasAspectName: Bool {return self._aspectName != nil}
  /// Clears the value of `aspectName`. Subsequent reads from it will return its default value.
  public mutating func clearAspectName() {self._aspectName = nil}

  /// Only set if the owner is an Aspect.
  /// Corresponds to AspectValue.AspectKey.getParameters()
  /// This field is deprecated as there might now be
  /// multiple aspects applied to the same target.
  /// These are the aspect parameters of the last aspect
  /// in 'aspects' (8) field.
  public var aspectParameters: Dictionary<String,Blaze_ExtraActionInfo.StringList> = [:]

  /// If the owner is an aspect, all aspects applied to the target
  public var aspects: [Blaze_ExtraActionInfo.AspectDescriptor] = []

  /// An id uniquely describing the shadowed action at the ActionOwner level.
  public var id: String {
    get {return _id ?? String()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  /// The mnemonic of the shadowed action. Used to distinguish actions with the
  /// same ActionType.
  public var mnemonic: String {
    get {return _mnemonic ?? String()}
    set {_mnemonic = newValue}
  }
  /// Returns true if `mnemonic` has been explicitly set.
  public var hasMnemonic: Bool {return self._mnemonic != nil}
  /// Clears the value of `mnemonic`. Subsequent reads from it will return its default value.
  public mutating func clearMnemonic() {self._mnemonic = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct StringList {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var value: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct AspectDescriptor {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Corresponds to AspectDescriptor.getName()
    public var aspectName: String {
      get {return _aspectName ?? String()}
      set {_aspectName = newValue}
    }
    /// Returns true if `aspectName` has been explicitly set.
    public var hasAspectName: Bool {return self._aspectName != nil}
    /// Clears the value of `aspectName`. Subsequent reads from it will return its default value.
    public mutating func clearAspectName() {self._aspectName = nil}

    /// Corresponds to AspectDescriptor.getParameters()
    public var aspectParameters: Dictionary<String,Blaze_ExtraActionInfo.AspectDescriptor.StringList> = [:]

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct StringList {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var value: [String] = []

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}

    fileprivate var _aspectName: String? = nil
  }

  public init() {}

  public var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
  fileprivate var _owner: String? = nil
  fileprivate var _aspectName: String? = nil
  fileprivate var _id: String? = nil
  fileprivate var _mnemonic: String? = nil
}

public struct Blaze_EnvironmentVariable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// It is possible that this name is not a valid variable identifier.
  public var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {self._name = nil}

  /// The value is unescaped and unquoted.
  public var value: String {
    get {return _value ?? String()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _name: String? = nil
  fileprivate var _value: String? = nil
}

/// Provides access to data that is specific to spawn actions.
/// Usually provided by actions using the "Spawn" & "Genrule" Mnemonics.
public struct Blaze_SpawnInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var argument: [String] = []

  /// A list of environment variables and their values. No order is enforced.
  public var variable: [Blaze_EnvironmentVariable] = []

  public var inputFile: [String] = []

  public var outputFile: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Provides access to data that is specific to C++ compile actions.
/// Usually provided by actions using the "CppCompile" Mnemonic.
public struct Blaze_CppCompileInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var tool: String {
    get {return _tool ?? String()}
    set {_tool = newValue}
  }
  /// Returns true if `tool` has been explicitly set.
  public var hasTool: Bool {return self._tool != nil}
  /// Clears the value of `tool`. Subsequent reads from it will return its default value.
  public mutating func clearTool() {self._tool = nil}

  public var compilerOption: [String] = []

  public var sourceFile: String {
    get {return _sourceFile ?? String()}
    set {_sourceFile = newValue}
  }
  /// Returns true if `sourceFile` has been explicitly set.
  public var hasSourceFile: Bool {return self._sourceFile != nil}
  /// Clears the value of `sourceFile`. Subsequent reads from it will return its default value.
  public mutating func clearSourceFile() {self._sourceFile = nil}

  public var outputFile: String {
    get {return _outputFile ?? String()}
    set {_outputFile = newValue}
  }
  /// Returns true if `outputFile` has been explicitly set.
  public var hasOutputFile: Bool {return self._outputFile != nil}
  /// Clears the value of `outputFile`. Subsequent reads from it will return its default value.
  public mutating func clearOutputFile() {self._outputFile = nil}

  /// Due to header discovery, this won't include headers unless the build is
  /// actually performed. If set, this field will include the value of
  /// "source_file" in addition to the headers.
  public var sourcesAndHeaders: [String] = []

  /// A list of environment variables and their values. No order is enforced.
  public var variable: [Blaze_EnvironmentVariable] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _tool: String? = nil
  fileprivate var _sourceFile: String? = nil
  fileprivate var _outputFile: String? = nil
}

/// Provides access to data that is specific to C++ link  actions.
/// Usually provided by actions using the "CppLink" Mnemonic.
public struct Blaze_CppLinkInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var inputFile: [String] = []

  public var outputFile: String {
    get {return _outputFile ?? String()}
    set {_outputFile = newValue}
  }
  /// Returns true if `outputFile` has been explicitly set.
  public var hasOutputFile: Bool {return self._outputFile != nil}
  /// Clears the value of `outputFile`. Subsequent reads from it will return its default value.
  public mutating func clearOutputFile() {self._outputFile = nil}

  public var interfaceOutputFile: String {
    get {return _interfaceOutputFile ?? String()}
    set {_interfaceOutputFile = newValue}
  }
  /// Returns true if `interfaceOutputFile` has been explicitly set.
  public var hasInterfaceOutputFile: Bool {return self._interfaceOutputFile != nil}
  /// Clears the value of `interfaceOutputFile`. Subsequent reads from it will return its default value.
  public mutating func clearInterfaceOutputFile() {self._interfaceOutputFile = nil}

  public var linkTargetType: String {
    get {return _linkTargetType ?? String()}
    set {_linkTargetType = newValue}
  }
  /// Returns true if `linkTargetType` has been explicitly set.
  public var hasLinkTargetType: Bool {return self._linkTargetType != nil}
  /// Clears the value of `linkTargetType`. Subsequent reads from it will return its default value.
  public mutating func clearLinkTargetType() {self._linkTargetType = nil}

  public var linkStaticness: String {
    get {return _linkStaticness ?? String()}
    set {_linkStaticness = newValue}
  }
  /// Returns true if `linkStaticness` has been explicitly set.
  public var hasLinkStaticness: Bool {return self._linkStaticness != nil}
  /// Clears the value of `linkStaticness`. Subsequent reads from it will return its default value.
  public mutating func clearLinkStaticness() {self._linkStaticness = nil}

  public var linkStamp: [String] = []

  public var buildInfoHeaderArtifact: [String] = []

  /// The list of command line options used for running the linking tool.
  public var linkOpt: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _outputFile: String? = nil
  fileprivate var _interfaceOutputFile: String? = nil
  fileprivate var _linkTargetType: String? = nil
  fileprivate var _linkStaticness: String? = nil
}

/// Provides access to data that is specific to java compile actions.
/// Usually provided by actions using the "Javac" Mnemonic.
public struct Blaze_JavaCompileInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var outputjar: String {
    get {return _outputjar ?? String()}
    set {_outputjar = newValue}
  }
  /// Returns true if `outputjar` has been explicitly set.
  public var hasOutputjar: Bool {return self._outputjar != nil}
  /// Clears the value of `outputjar`. Subsequent reads from it will return its default value.
  public mutating func clearOutputjar() {self._outputjar = nil}

  public var classpath: [String] = []

  public var sourcepath: [String] = []

  public var sourceFile: [String] = []

  public var javacOpt: [String] = []

  public var processor: [String] = []

  public var processorpath: [String] = []

  public var bootclasspath: [String] = []

  public var argument: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _outputjar: String? = nil
}

/// Provides access to data that is specific to python rules.
/// Usually provided by actions using the "Python" Mnemonic.
public struct Blaze_PythonInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sourceFile: [String] = []

  public var depFile: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Extension support defined in extra_actions_base.proto.

extension Blaze_ExtraActionInfo {

  public var Blaze_SpawnInfo_spawnInfo: Blaze_SpawnInfo {
    get {return getExtensionValue(ext: Blaze_SpawnInfo.Extensions.spawn_info) ?? Blaze_SpawnInfo()}
    set {setExtensionValue(ext: Blaze_SpawnInfo.Extensions.spawn_info, value: newValue)}
  }
  /// Returns true if extension `Blaze_SpawnInfo.Extensions.spawn_info`
  /// has been explicitly set.
  public var hasBlaze_SpawnInfo_spawnInfo: Bool {
    return hasExtensionValue(ext: Blaze_SpawnInfo.Extensions.spawn_info)
  }
  /// Clears the value of extension `Blaze_SpawnInfo.Extensions.spawn_info`.
  /// Subsequent reads from it will return its default value.
  public mutating func clearBlaze_SpawnInfo_spawnInfo() {
    clearExtensionValue(ext: Blaze_SpawnInfo.Extensions.spawn_info)
  }

  public var Blaze_CppCompileInfo_cppCompileInfo: Blaze_CppCompileInfo {
    get {return getExtensionValue(ext: Blaze_CppCompileInfo.Extensions.cpp_compile_info) ?? Blaze_CppCompileInfo()}
    set {setExtensionValue(ext: Blaze_CppCompileInfo.Extensions.cpp_compile_info, value: newValue)}
  }
  /// Returns true if extension `Blaze_CppCompileInfo.Extensions.cpp_compile_info`
  /// has been explicitly set.
  public var hasBlaze_CppCompileInfo_cppCompileInfo: Bool {
    return hasExtensionValue(ext: Blaze_CppCompileInfo.Extensions.cpp_compile_info)
  }
  /// Clears the value of extension `Blaze_CppCompileInfo.Extensions.cpp_compile_info`.
  /// Subsequent reads from it will return its default value.
  public mutating func clearBlaze_CppCompileInfo_cppCompileInfo() {
    clearExtensionValue(ext: Blaze_CppCompileInfo.Extensions.cpp_compile_info)
  }

  public var Blaze_CppLinkInfo_cppLinkInfo: Blaze_CppLinkInfo {
    get {return getExtensionValue(ext: Blaze_CppLinkInfo.Extensions.cpp_link_info) ?? Blaze_CppLinkInfo()}
    set {setExtensionValue(ext: Blaze_CppLinkInfo.Extensions.cpp_link_info, value: newValue)}
  }
  /// Returns true if extension `Blaze_CppLinkInfo.Extensions.cpp_link_info`
  /// has been explicitly set.
  public var hasBlaze_CppLinkInfo_cppLinkInfo: Bool {
    return hasExtensionValue(ext: Blaze_CppLinkInfo.Extensions.cpp_link_info)
  }
  /// Clears the value of extension `Blaze_CppLinkInfo.Extensions.cpp_link_info`.
  /// Subsequent reads from it will return its default value.
  public mutating func clearBlaze_CppLinkInfo_cppLinkInfo() {
    clearExtensionValue(ext: Blaze_CppLinkInfo.Extensions.cpp_link_info)
  }

  public var Blaze_JavaCompileInfo_javaCompileInfo: Blaze_JavaCompileInfo {
    get {return getExtensionValue(ext: Blaze_JavaCompileInfo.Extensions.java_compile_info) ?? Blaze_JavaCompileInfo()}
    set {setExtensionValue(ext: Blaze_JavaCompileInfo.Extensions.java_compile_info, value: newValue)}
  }
  /// Returns true if extension `Blaze_JavaCompileInfo.Extensions.java_compile_info`
  /// has been explicitly set.
  public var hasBlaze_JavaCompileInfo_javaCompileInfo: Bool {
    return hasExtensionValue(ext: Blaze_JavaCompileInfo.Extensions.java_compile_info)
  }
  /// Clears the value of extension `Blaze_JavaCompileInfo.Extensions.java_compile_info`.
  /// Subsequent reads from it will return its default value.
  public mutating func clearBlaze_JavaCompileInfo_javaCompileInfo() {
    clearExtensionValue(ext: Blaze_JavaCompileInfo.Extensions.java_compile_info)
  }

  public var Blaze_PythonInfo_pythonInfo: Blaze_PythonInfo {
    get {return getExtensionValue(ext: Blaze_PythonInfo.Extensions.python_info) ?? Blaze_PythonInfo()}
    set {setExtensionValue(ext: Blaze_PythonInfo.Extensions.python_info, value: newValue)}
  }
  /// Returns true if extension `Blaze_PythonInfo.Extensions.python_info`
  /// has been explicitly set.
  public var hasBlaze_PythonInfo_pythonInfo: Bool {
    return hasExtensionValue(ext: Blaze_PythonInfo.Extensions.python_info)
  }
  /// Clears the value of extension `Blaze_PythonInfo.Extensions.python_info`.
  /// Subsequent reads from it will return its default value.
  public mutating func clearBlaze_PythonInfo_pythonInfo() {
    clearExtensionValue(ext: Blaze_PythonInfo.Extensions.python_info)
  }

}

/// A `SwiftProtobuf.SimpleExtensionMap` that includes all of the extensions defined by
/// this .proto file. It can be used any place an `SwiftProtobuf.ExtensionMap` is needed
/// in parsing, or it can be combined with other `SwiftProtobuf.SimpleExtensionMap`s to create
/// a larger `SwiftProtobuf.SimpleExtensionMap`.
public let Blaze_ExtraActionsBase_Extensions: SwiftProtobuf.SimpleExtensionMap = [
  Blaze_SpawnInfo.Extensions.spawn_info,
  Blaze_CppCompileInfo.Extensions.cpp_compile_info,
  Blaze_CppLinkInfo.Extensions.cpp_link_info,
  Blaze_JavaCompileInfo.Extensions.java_compile_info,
  Blaze_PythonInfo.Extensions.python_info
]

extension Blaze_SpawnInfo {
  enum Extensions {
    static let spawn_info = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalMessageExtensionField<Blaze_SpawnInfo>, Blaze_ExtraActionInfo>(
      _protobuf_fieldNumber: 1003,
      fieldName: "blaze.SpawnInfo.spawn_info"
    )
  }
}

extension Blaze_CppCompileInfo {
  enum Extensions {
    static let cpp_compile_info = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalMessageExtensionField<Blaze_CppCompileInfo>, Blaze_ExtraActionInfo>(
      _protobuf_fieldNumber: 1001,
      fieldName: "blaze.CppCompileInfo.cpp_compile_info"
    )
  }
}

extension Blaze_CppLinkInfo {
  enum Extensions {
    static let cpp_link_info = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalMessageExtensionField<Blaze_CppLinkInfo>, Blaze_ExtraActionInfo>(
      _protobuf_fieldNumber: 1002,
      fieldName: "blaze.CppLinkInfo.cpp_link_info"
    )
  }
}

extension Blaze_JavaCompileInfo {
  enum Extensions {
    static let java_compile_info = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalMessageExtensionField<Blaze_JavaCompileInfo>, Blaze_ExtraActionInfo>(
      _protobuf_fieldNumber: 1000,
      fieldName: "blaze.JavaCompileInfo.java_compile_info"
    )
  }
}

extension Blaze_PythonInfo {
  enum Extensions {
    static let python_info = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalMessageExtensionField<Blaze_PythonInfo>, Blaze_ExtraActionInfo>(
      _protobuf_fieldNumber: 1005,
      fieldName: "blaze.PythonInfo.python_info"
    )
  }
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "blaze"

extension Blaze_ExtraActionSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExtraActionSummary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.action) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.action)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.action.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.action, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Blaze_ExtraActionSummary, rhs: Blaze_ExtraActionSummary) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Blaze_DetailedExtraActionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DetailedExtraActionInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "triggering_file"),
    2: .same(proto: "action"),
  ]

  fileprivate class _StorageClass {
    var _triggeringFile: String? = nil
    var _action: Blaze_ExtraActionInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _triggeringFile = source._triggeringFile
      _action = source._action
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._action == nil {return false}
      if let v = _storage._action, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._triggeringFile)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._action)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._triggeringFile {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._action {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Blaze_DetailedExtraActionInfo, rhs: Blaze_DetailedExtraActionInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._triggeringFile != rhs_storage._triggeringFile {return false}
        if _storage._action != rhs_storage._action {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Blaze_ExtraActionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExtraActionInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "owner"),
    6: .standard(proto: "aspect_name"),
    7: .standard(proto: "aspect_parameters"),
    8: .same(proto: "aspects"),
    2: .same(proto: "id"),
    5: .same(proto: "mnemonic"),
  ]

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._owner)
      case 2: try decoder.decodeSingularStringField(value: &self._id)
      case 5: try decoder.decodeSingularStringField(value: &self._mnemonic)
      case 6: try decoder.decodeSingularStringField(value: &self._aspectName)
      case 7: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Blaze_ExtraActionInfo.StringList>.self, value: &self.aspectParameters)
      case 8: try decoder.decodeRepeatedMessageField(value: &self.aspects)
      case 1000..<536870912:
        try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: Blaze_ExtraActionInfo.self, fieldNumber: fieldNumber)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._owner {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._id {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._mnemonic {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }
    if let v = self._aspectName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    }
    if !self.aspectParameters.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Blaze_ExtraActionInfo.StringList>.self, value: self.aspectParameters, fieldNumber: 7)
    }
    if !self.aspects.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.aspects, fieldNumber: 8)
    }
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1000, end: 536870912)
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Blaze_ExtraActionInfo, rhs: Blaze_ExtraActionInfo) -> Bool {
    if lhs._owner != rhs._owner {return false}
    if lhs._aspectName != rhs._aspectName {return false}
    if lhs.aspectParameters != rhs.aspectParameters {return false}
    if lhs.aspects != rhs.aspects {return false}
    if lhs._id != rhs._id {return false}
    if lhs._mnemonic != rhs._mnemonic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension Blaze_ExtraActionInfo.StringList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Blaze_ExtraActionInfo.protoMessageName + ".StringList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.value)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitRepeatedStringField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Blaze_ExtraActionInfo.StringList, rhs: Blaze_ExtraActionInfo.StringList) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Blaze_ExtraActionInfo.AspectDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Blaze_ExtraActionInfo.protoMessageName + ".AspectDescriptor"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "aspect_name"),
    2: .standard(proto: "aspect_parameters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._aspectName)
      case 2: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Blaze_ExtraActionInfo.AspectDescriptor.StringList>.self, value: &self.aspectParameters)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._aspectName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if !self.aspectParameters.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Blaze_ExtraActionInfo.AspectDescriptor.StringList>.self, value: self.aspectParameters, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Blaze_ExtraActionInfo.AspectDescriptor, rhs: Blaze_ExtraActionInfo.AspectDescriptor) -> Bool {
    if lhs._aspectName != rhs._aspectName {return false}
    if lhs.aspectParameters != rhs.aspectParameters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Blaze_ExtraActionInfo.AspectDescriptor.StringList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Blaze_ExtraActionInfo.AspectDescriptor.protoMessageName + ".StringList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.value)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitRepeatedStringField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Blaze_ExtraActionInfo.AspectDescriptor.StringList, rhs: Blaze_ExtraActionInfo.AspectDescriptor.StringList) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Blaze_EnvironmentVariable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EnvironmentVariable"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
  ]

  public var isInitialized: Bool {
    if self._name == nil {return false}
    if self._value == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._name)
      case 2: try decoder.decodeSingularStringField(value: &self._value)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._value {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Blaze_EnvironmentVariable, rhs: Blaze_EnvironmentVariable) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Blaze_SpawnInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SpawnInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "argument"),
    2: .same(proto: "variable"),
    4: .standard(proto: "input_file"),
    5: .standard(proto: "output_file"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.variable) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.argument)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.variable)
      case 4: try decoder.decodeRepeatedStringField(value: &self.inputFile)
      case 5: try decoder.decodeRepeatedStringField(value: &self.outputFile)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.argument.isEmpty {
      try visitor.visitRepeatedStringField(value: self.argument, fieldNumber: 1)
    }
    if !self.variable.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.variable, fieldNumber: 2)
    }
    if !self.inputFile.isEmpty {
      try visitor.visitRepeatedStringField(value: self.inputFile, fieldNumber: 4)
    }
    if !self.outputFile.isEmpty {
      try visitor.visitRepeatedStringField(value: self.outputFile, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Blaze_SpawnInfo, rhs: Blaze_SpawnInfo) -> Bool {
    if lhs.argument != rhs.argument {return false}
    if lhs.variable != rhs.variable {return false}
    if lhs.inputFile != rhs.inputFile {return false}
    if lhs.outputFile != rhs.outputFile {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Blaze_CppCompileInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CppCompileInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tool"),
    2: .standard(proto: "compiler_option"),
    3: .standard(proto: "source_file"),
    4: .standard(proto: "output_file"),
    5: .standard(proto: "sources_and_headers"),
    6: .same(proto: "variable"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.variable) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._tool)
      case 2: try decoder.decodeRepeatedStringField(value: &self.compilerOption)
      case 3: try decoder.decodeSingularStringField(value: &self._sourceFile)
      case 4: try decoder.decodeSingularStringField(value: &self._outputFile)
      case 5: try decoder.decodeRepeatedStringField(value: &self.sourcesAndHeaders)
      case 6: try decoder.decodeRepeatedMessageField(value: &self.variable)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._tool {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if !self.compilerOption.isEmpty {
      try visitor.visitRepeatedStringField(value: self.compilerOption, fieldNumber: 2)
    }
    if let v = self._sourceFile {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._outputFile {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    if !self.sourcesAndHeaders.isEmpty {
      try visitor.visitRepeatedStringField(value: self.sourcesAndHeaders, fieldNumber: 5)
    }
    if !self.variable.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.variable, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Blaze_CppCompileInfo, rhs: Blaze_CppCompileInfo) -> Bool {
    if lhs._tool != rhs._tool {return false}
    if lhs.compilerOption != rhs.compilerOption {return false}
    if lhs._sourceFile != rhs._sourceFile {return false}
    if lhs._outputFile != rhs._outputFile {return false}
    if lhs.sourcesAndHeaders != rhs.sourcesAndHeaders {return false}
    if lhs.variable != rhs.variable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Blaze_CppLinkInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CppLinkInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "input_file"),
    2: .standard(proto: "output_file"),
    3: .standard(proto: "interface_output_file"),
    4: .standard(proto: "link_target_type"),
    5: .standard(proto: "link_staticness"),
    6: .standard(proto: "link_stamp"),
    7: .standard(proto: "build_info_header_artifact"),
    8: .standard(proto: "link_opt"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.inputFile)
      case 2: try decoder.decodeSingularStringField(value: &self._outputFile)
      case 3: try decoder.decodeSingularStringField(value: &self._interfaceOutputFile)
      case 4: try decoder.decodeSingularStringField(value: &self._linkTargetType)
      case 5: try decoder.decodeSingularStringField(value: &self._linkStaticness)
      case 6: try decoder.decodeRepeatedStringField(value: &self.linkStamp)
      case 7: try decoder.decodeRepeatedStringField(value: &self.buildInfoHeaderArtifact)
      case 8: try decoder.decodeRepeatedStringField(value: &self.linkOpt)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.inputFile.isEmpty {
      try visitor.visitRepeatedStringField(value: self.inputFile, fieldNumber: 1)
    }
    if let v = self._outputFile {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._interfaceOutputFile {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._linkTargetType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    if let v = self._linkStaticness {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }
    if !self.linkStamp.isEmpty {
      try visitor.visitRepeatedStringField(value: self.linkStamp, fieldNumber: 6)
    }
    if !self.buildInfoHeaderArtifact.isEmpty {
      try visitor.visitRepeatedStringField(value: self.buildInfoHeaderArtifact, fieldNumber: 7)
    }
    if !self.linkOpt.isEmpty {
      try visitor.visitRepeatedStringField(value: self.linkOpt, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Blaze_CppLinkInfo, rhs: Blaze_CppLinkInfo) -> Bool {
    if lhs.inputFile != rhs.inputFile {return false}
    if lhs._outputFile != rhs._outputFile {return false}
    if lhs._interfaceOutputFile != rhs._interfaceOutputFile {return false}
    if lhs._linkTargetType != rhs._linkTargetType {return false}
    if lhs._linkStaticness != rhs._linkStaticness {return false}
    if lhs.linkStamp != rhs.linkStamp {return false}
    if lhs.buildInfoHeaderArtifact != rhs.buildInfoHeaderArtifact {return false}
    if lhs.linkOpt != rhs.linkOpt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Blaze_JavaCompileInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".JavaCompileInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "outputjar"),
    2: .same(proto: "classpath"),
    3: .same(proto: "sourcepath"),
    4: .standard(proto: "source_file"),
    5: .standard(proto: "javac_opt"),
    6: .same(proto: "processor"),
    7: .same(proto: "processorpath"),
    8: .same(proto: "bootclasspath"),
    9: .same(proto: "argument"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._outputjar)
      case 2: try decoder.decodeRepeatedStringField(value: &self.classpath)
      case 3: try decoder.decodeRepeatedStringField(value: &self.sourcepath)
      case 4: try decoder.decodeRepeatedStringField(value: &self.sourceFile)
      case 5: try decoder.decodeRepeatedStringField(value: &self.javacOpt)
      case 6: try decoder.decodeRepeatedStringField(value: &self.processor)
      case 7: try decoder.decodeRepeatedStringField(value: &self.processorpath)
      case 8: try decoder.decodeRepeatedStringField(value: &self.bootclasspath)
      case 9: try decoder.decodeRepeatedStringField(value: &self.argument)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._outputjar {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if !self.classpath.isEmpty {
      try visitor.visitRepeatedStringField(value: self.classpath, fieldNumber: 2)
    }
    if !self.sourcepath.isEmpty {
      try visitor.visitRepeatedStringField(value: self.sourcepath, fieldNumber: 3)
    }
    if !self.sourceFile.isEmpty {
      try visitor.visitRepeatedStringField(value: self.sourceFile, fieldNumber: 4)
    }
    if !self.javacOpt.isEmpty {
      try visitor.visitRepeatedStringField(value: self.javacOpt, fieldNumber: 5)
    }
    if !self.processor.isEmpty {
      try visitor.visitRepeatedStringField(value: self.processor, fieldNumber: 6)
    }
    if !self.processorpath.isEmpty {
      try visitor.visitRepeatedStringField(value: self.processorpath, fieldNumber: 7)
    }
    if !self.bootclasspath.isEmpty {
      try visitor.visitRepeatedStringField(value: self.bootclasspath, fieldNumber: 8)
    }
    if !self.argument.isEmpty {
      try visitor.visitRepeatedStringField(value: self.argument, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Blaze_JavaCompileInfo, rhs: Blaze_JavaCompileInfo) -> Bool {
    if lhs._outputjar != rhs._outputjar {return false}
    if lhs.classpath != rhs.classpath {return false}
    if lhs.sourcepath != rhs.sourcepath {return false}
    if lhs.sourceFile != rhs.sourceFile {return false}
    if lhs.javacOpt != rhs.javacOpt {return false}
    if lhs.processor != rhs.processor {return false}
    if lhs.processorpath != rhs.processorpath {return false}
    if lhs.bootclasspath != rhs.bootclasspath {return false}
    if lhs.argument != rhs.argument {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Blaze_PythonInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PythonInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "source_file"),
    2: .standard(proto: "dep_file"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.sourceFile)
      case 2: try decoder.decodeRepeatedStringField(value: &self.depFile)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sourceFile.isEmpty {
      try visitor.visitRepeatedStringField(value: self.sourceFile, fieldNumber: 1)
    }
    if !self.depFile.isEmpty {
      try visitor.visitRepeatedStringField(value: self.depFile, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Blaze_PythonInfo, rhs: Blaze_PythonInfo) -> Bool {
    if lhs.sourceFile != rhs.sourceFile {return false}
    if lhs.depFile != rhs.depFile {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
